{"ast":null,"code":"'use strict';\n/* eslint-disable max-params */\n\nvar trim = require('trim');\n\nvar repeat = require('repeat-string');\n\nvar decimal = require('is-decimal');\n\nvar getIndent = require('../util/get-indentation');\n\nvar removeIndent = require('../util/remove-indentation');\n\nvar interrupt = require('../util/interrupt');\n\nmodule.exports = list;\nvar C_ASTERISK = '*';\nvar C_UNDERSCORE = '_';\nvar C_PLUS = '+';\nvar C_DASH = '-';\nvar C_DOT = '.';\nvar C_SPACE = ' ';\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar C_PAREN_CLOSE = ')';\nvar C_X_LOWER = 'x';\nvar TAB_SIZE = 4;\nvar EXPRESSION_LOOSE_LIST_ITEM = /\\n\\n(?!\\s*$)/;\nvar EXPRESSION_TASK_ITEM = /^\\[([ \\t]|x|X)][ \\t]/;\nvar EXPRESSION_BULLET = /^([ \\t]*)([*+-]|\\d+[.)])( {1,4}(?! )| |\\t|$|(?=\\n))([^\\n]*)/;\nvar EXPRESSION_PEDANTIC_BULLET = /^([ \\t]*)([*+-]|\\d+[.)])([ \\t]+)/;\nvar EXPRESSION_INITIAL_INDENT = /^( {1,4}|\\t)?/gm;\n/* Map of characters which can be used to mark\n * list-items. */\n\nvar LIST_UNORDERED_MARKERS = {};\nLIST_UNORDERED_MARKERS[C_ASTERISK] = true;\nLIST_UNORDERED_MARKERS[C_PLUS] = true;\nLIST_UNORDERED_MARKERS[C_DASH] = true;\n/* Map of characters which can be used to mark\n * list-items after a digit. */\n\nvar LIST_ORDERED_MARKERS = {};\nLIST_ORDERED_MARKERS[C_DOT] = true;\n/* Map of characters which can be used to mark\n * list-items after a digit. */\n\nvar LIST_ORDERED_COMMONMARK_MARKERS = {};\nLIST_ORDERED_COMMONMARK_MARKERS[C_DOT] = true;\nLIST_ORDERED_COMMONMARK_MARKERS[C_PAREN_CLOSE] = true;\n\nfunction list(eat, value, silent) {\n  var self = this;\n  var commonmark = self.options.commonmark;\n  var pedantic = self.options.pedantic;\n  var tokenizers = self.blockTokenizers;\n  var interuptors = self.interruptList;\n  var markers;\n  var index = 0;\n  var length = value.length;\n  var start = null;\n  var size = 0;\n  var queue;\n  var ordered;\n  var character;\n  var marker;\n  var nextIndex;\n  var startIndex;\n  var prefixed;\n  var currentMarker;\n  var content;\n  var line;\n  var prevEmpty;\n  var empty;\n  var items;\n  var allLines;\n  var emptyLines;\n  var item;\n  var enterTop;\n  var exitBlockquote;\n  var isLoose;\n  var node;\n  var now;\n  var end;\n  var indented;\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character === C_TAB) {\n      size += TAB_SIZE - size % TAB_SIZE;\n    } else if (character === C_SPACE) {\n      size++;\n    } else {\n      break;\n    }\n\n    index++;\n  }\n\n  if (size >= TAB_SIZE) {\n    return;\n  }\n\n  character = value.charAt(index);\n  markers = commonmark ? LIST_ORDERED_COMMONMARK_MARKERS : LIST_ORDERED_MARKERS;\n\n  if (LIST_UNORDERED_MARKERS[character] === true) {\n    marker = character;\n    ordered = false;\n  } else {\n    ordered = true;\n    queue = '';\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (!decimal(character)) {\n        break;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    character = value.charAt(index);\n\n    if (!queue || markers[character] !== true) {\n      return;\n    }\n\n    start = parseInt(queue, 10);\n    marker = character;\n  }\n\n  character = value.charAt(++index);\n\n  if (character !== C_SPACE && character !== C_TAB) {\n    return;\n  }\n\n  if (silent) {\n    return true;\n  }\n\n  index = 0;\n  items = [];\n  allLines = [];\n  emptyLines = [];\n\n  while (index < length) {\n    nextIndex = value.indexOf(C_NEWLINE, index);\n    startIndex = index;\n    prefixed = false;\n    indented = false;\n\n    if (nextIndex === -1) {\n      nextIndex = length;\n    }\n\n    end = index + TAB_SIZE;\n    size = 0;\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character === C_TAB) {\n        size += TAB_SIZE - size % TAB_SIZE;\n      } else if (character === C_SPACE) {\n        size++;\n      } else {\n        break;\n      }\n\n      index++;\n    }\n\n    if (size >= TAB_SIZE) {\n      indented = true;\n    }\n\n    if (item && size >= item.indent) {\n      indented = true;\n    }\n\n    character = value.charAt(index);\n    currentMarker = null;\n\n    if (!indented) {\n      if (LIST_UNORDERED_MARKERS[character] === true) {\n        currentMarker = character;\n        index++;\n        size++;\n      } else {\n        queue = '';\n\n        while (index < length) {\n          character = value.charAt(index);\n\n          if (!decimal(character)) {\n            break;\n          }\n\n          queue += character;\n          index++;\n        }\n\n        character = value.charAt(index);\n        index++;\n\n        if (queue && markers[character] === true) {\n          currentMarker = character;\n          size += queue.length + 1;\n        }\n      }\n\n      if (currentMarker) {\n        character = value.charAt(index);\n\n        if (character === C_TAB) {\n          size += TAB_SIZE - size % TAB_SIZE;\n          index++;\n        } else if (character === C_SPACE) {\n          end = index + TAB_SIZE;\n\n          while (index < end) {\n            if (value.charAt(index) !== C_SPACE) {\n              break;\n            }\n\n            index++;\n            size++;\n          }\n\n          if (index === end && value.charAt(index) === C_SPACE) {\n            index -= TAB_SIZE - 1;\n            size -= TAB_SIZE - 1;\n          }\n        } else if (character !== C_NEWLINE && character !== '') {\n          currentMarker = null;\n        }\n      }\n    }\n\n    if (currentMarker) {\n      if (!pedantic && marker !== currentMarker) {\n        break;\n      }\n\n      prefixed = true;\n    } else {\n      if (!commonmark && !indented && value.charAt(startIndex) === C_SPACE) {\n        indented = true;\n      } else if (commonmark && item) {\n        indented = size >= item.indent || size > TAB_SIZE;\n      }\n\n      prefixed = false;\n      index = startIndex;\n    }\n\n    line = value.slice(startIndex, nextIndex);\n    content = startIndex === index ? line : value.slice(index, nextIndex);\n\n    if (currentMarker === C_ASTERISK || currentMarker === C_UNDERSCORE || currentMarker === C_DASH) {\n      if (tokenizers.thematicBreak.call(self, eat, line, true)) {\n        break;\n      }\n    }\n\n    prevEmpty = empty;\n    empty = !trim(content).length;\n\n    if (indented && item) {\n      item.value = item.value.concat(emptyLines, line);\n      allLines = allLines.concat(emptyLines, line);\n      emptyLines = [];\n    } else if (prefixed) {\n      if (emptyLines.length !== 0) {\n        item.value.push('');\n        item.trail = emptyLines.concat();\n      }\n\n      item = {\n        value: [line],\n        indent: size,\n        trail: []\n      };\n      items.push(item);\n      allLines = allLines.concat(emptyLines, line);\n      emptyLines = [];\n    } else if (empty) {\n      if (prevEmpty) {\n        break;\n      }\n\n      emptyLines.push(line);\n    } else {\n      if (prevEmpty) {\n        break;\n      }\n\n      if (interrupt(interuptors, tokenizers, self, [eat, line, true])) {\n        break;\n      }\n\n      item.value = item.value.concat(emptyLines, line);\n      allLines = allLines.concat(emptyLines, line);\n      emptyLines = [];\n    }\n\n    index = nextIndex + 1;\n  }\n\n  node = eat(allLines.join(C_NEWLINE)).reset({\n    type: 'list',\n    ordered: ordered,\n    start: start,\n    loose: null,\n    children: []\n  });\n  enterTop = self.enterList();\n  exitBlockquote = self.enterBlock();\n  isLoose = false;\n  index = -1;\n  length = items.length;\n\n  while (++index < length) {\n    item = items[index].value.join(C_NEWLINE);\n    now = eat.now();\n    item = eat(item)(listItem(self, item, now), node);\n\n    if (item.loose) {\n      isLoose = true;\n    }\n\n    item = items[index].trail.join(C_NEWLINE);\n\n    if (index !== length - 1) {\n      item += C_NEWLINE;\n    }\n\n    eat(item);\n  }\n\n  enterTop();\n  exitBlockquote();\n  node.loose = isLoose;\n  return node;\n}\n\nfunction listItem(ctx, value, position) {\n  var offsets = ctx.offset;\n  var fn = ctx.options.pedantic ? pedanticListItem : normalListItem;\n  var checked = null;\n  var task;\n  var indent;\n  value = fn.apply(null, arguments);\n\n  if (ctx.options.gfm) {\n    task = value.match(EXPRESSION_TASK_ITEM);\n\n    if (task) {\n      indent = task[0].length;\n      checked = task[1].toLowerCase() === C_X_LOWER;\n      offsets[position.line] += indent;\n      value = value.slice(indent);\n    }\n  }\n\n  return {\n    type: 'listItem',\n    loose: EXPRESSION_LOOSE_LIST_ITEM.test(value) || value.charAt(value.length - 1) === C_NEWLINE,\n    checked: checked,\n    children: ctx.tokenizeBlock(value, position)\n  };\n}\n/* Create a list-item using overly simple mechanics. */\n\n\nfunction pedanticListItem(ctx, value, position) {\n  var offsets = ctx.offset;\n  var line = position.line;\n  /* Remove the list-item’s bullet. */\n\n  value = value.replace(EXPRESSION_PEDANTIC_BULLET, replacer);\n  /* The initial line was also matched by the below, so\n   * we reset the `line`. */\n\n  line = position.line;\n  return value.replace(EXPRESSION_INITIAL_INDENT, replacer);\n  /* A simple replacer which removed all matches,\n   * and adds their length to `offset`. */\n\n  function replacer($0) {\n    offsets[line] = (offsets[line] || 0) + $0.length;\n    line++;\n    return '';\n  }\n}\n/* Create a list-item using sane mechanics. */\n\n\nfunction normalListItem(ctx, value, position) {\n  var offsets = ctx.offset;\n  var line = position.line;\n  var max;\n  var bullet;\n  var rest;\n  var lines;\n  var trimmedLines;\n  var index;\n  var length;\n  /* Remove the list-item’s bullet. */\n\n  value = value.replace(EXPRESSION_BULLET, replacer);\n  lines = value.split(C_NEWLINE);\n  trimmedLines = removeIndent(value, getIndent(max).indent).split(C_NEWLINE);\n  /* We replaced the initial bullet with something\n   * else above, which was used to trick\n   * `removeIndentation` into removing some more\n   * characters when possible.  However, that could\n   * result in the initial line to be stripped more\n   * than it should be. */\n\n  trimmedLines[0] = rest;\n  offsets[line] = (offsets[line] || 0) + bullet.length;\n  line++;\n  index = 0;\n  length = lines.length;\n\n  while (++index < length) {\n    offsets[line] = (offsets[line] || 0) + lines[index].length - trimmedLines[index].length;\n    line++;\n  }\n\n  return trimmedLines.join(C_NEWLINE);\n\n  function replacer($0, $1, $2, $3, $4) {\n    bullet = $1 + $2 + $3;\n    rest = $4;\n    /* Make sure that the first nine numbered list items\n     * can indent with an extra space.  That is, when\n     * the bullet did not receive an extra final space. */\n\n    if (Number($2) < 10 && bullet.length % 2 === 1) {\n      $2 = C_SPACE + $2;\n    }\n\n    max = $1 + repeat(C_SPACE, $2.length) + $3;\n    return max + rest;\n  }\n}","map":{"version":3,"names":["trim","require","repeat","decimal","getIndent","removeIndent","interrupt","module","exports","list","C_ASTERISK","C_UNDERSCORE","C_PLUS","C_DASH","C_DOT","C_SPACE","C_NEWLINE","C_TAB","C_PAREN_CLOSE","C_X_LOWER","TAB_SIZE","EXPRESSION_LOOSE_LIST_ITEM","EXPRESSION_TASK_ITEM","EXPRESSION_BULLET","EXPRESSION_PEDANTIC_BULLET","EXPRESSION_INITIAL_INDENT","LIST_UNORDERED_MARKERS","LIST_ORDERED_MARKERS","LIST_ORDERED_COMMONMARK_MARKERS","eat","value","silent","self","commonmark","options","pedantic","tokenizers","blockTokenizers","interuptors","interruptList","markers","index","length","start","size","queue","ordered","character","marker","nextIndex","startIndex","prefixed","currentMarker","content","line","prevEmpty","empty","items","allLines","emptyLines","item","enterTop","exitBlockquote","isLoose","node","now","end","indented","charAt","parseInt","indexOf","indent","slice","thematicBreak","call","concat","push","trail","join","reset","type","loose","children","enterList","enterBlock","listItem","ctx","position","offsets","offset","fn","pedanticListItem","normalListItem","checked","task","apply","arguments","gfm","match","toLowerCase","test","tokenizeBlock","replace","replacer","$0","max","bullet","rest","lines","trimmedLines","split","$1","$2","$3","$4","Number"],"sources":["/Users/ghaz/Documents/projects/PersonalWebsite/node_modules/remark-parse/lib/tokenize/list.js"],"sourcesContent":["'use strict';\n\n/* eslint-disable max-params */\n\nvar trim = require('trim');\nvar repeat = require('repeat-string');\nvar decimal = require('is-decimal');\nvar getIndent = require('../util/get-indentation');\nvar removeIndent = require('../util/remove-indentation');\nvar interrupt = require('../util/interrupt');\n\nmodule.exports = list;\n\nvar C_ASTERISK = '*';\nvar C_UNDERSCORE = '_';\nvar C_PLUS = '+';\nvar C_DASH = '-';\nvar C_DOT = '.';\nvar C_SPACE = ' ';\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar C_PAREN_CLOSE = ')';\nvar C_X_LOWER = 'x';\n\nvar TAB_SIZE = 4;\nvar EXPRESSION_LOOSE_LIST_ITEM = /\\n\\n(?!\\s*$)/;\nvar EXPRESSION_TASK_ITEM = /^\\[([ \\t]|x|X)][ \\t]/;\nvar EXPRESSION_BULLET = /^([ \\t]*)([*+-]|\\d+[.)])( {1,4}(?! )| |\\t|$|(?=\\n))([^\\n]*)/;\nvar EXPRESSION_PEDANTIC_BULLET = /^([ \\t]*)([*+-]|\\d+[.)])([ \\t]+)/;\nvar EXPRESSION_INITIAL_INDENT = /^( {1,4}|\\t)?/gm;\n\n/* Map of characters which can be used to mark\n * list-items. */\nvar LIST_UNORDERED_MARKERS = {};\n\nLIST_UNORDERED_MARKERS[C_ASTERISK] = true;\nLIST_UNORDERED_MARKERS[C_PLUS] = true;\nLIST_UNORDERED_MARKERS[C_DASH] = true;\n\n/* Map of characters which can be used to mark\n * list-items after a digit. */\nvar LIST_ORDERED_MARKERS = {};\n\nLIST_ORDERED_MARKERS[C_DOT] = true;\n\n/* Map of characters which can be used to mark\n * list-items after a digit. */\nvar LIST_ORDERED_COMMONMARK_MARKERS = {};\n\nLIST_ORDERED_COMMONMARK_MARKERS[C_DOT] = true;\nLIST_ORDERED_COMMONMARK_MARKERS[C_PAREN_CLOSE] = true;\n\nfunction list(eat, value, silent) {\n  var self = this;\n  var commonmark = self.options.commonmark;\n  var pedantic = self.options.pedantic;\n  var tokenizers = self.blockTokenizers;\n  var interuptors = self.interruptList;\n  var markers;\n  var index = 0;\n  var length = value.length;\n  var start = null;\n  var size = 0;\n  var queue;\n  var ordered;\n  var character;\n  var marker;\n  var nextIndex;\n  var startIndex;\n  var prefixed;\n  var currentMarker;\n  var content;\n  var line;\n  var prevEmpty;\n  var empty;\n  var items;\n  var allLines;\n  var emptyLines;\n  var item;\n  var enterTop;\n  var exitBlockquote;\n  var isLoose;\n  var node;\n  var now;\n  var end;\n  var indented;\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character === C_TAB) {\n      size += TAB_SIZE - (size % TAB_SIZE);\n    } else if (character === C_SPACE) {\n      size++;\n    } else {\n      break;\n    }\n\n    index++;\n  }\n\n  if (size >= TAB_SIZE) {\n    return;\n  }\n\n  character = value.charAt(index);\n\n  markers = commonmark ?\n    LIST_ORDERED_COMMONMARK_MARKERS :\n    LIST_ORDERED_MARKERS;\n\n  if (LIST_UNORDERED_MARKERS[character] === true) {\n    marker = character;\n    ordered = false;\n  } else {\n    ordered = true;\n    queue = '';\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (!decimal(character)) {\n        break;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    character = value.charAt(index);\n\n    if (!queue || markers[character] !== true) {\n      return;\n    }\n\n    start = parseInt(queue, 10);\n    marker = character;\n  }\n\n  character = value.charAt(++index);\n\n  if (character !== C_SPACE && character !== C_TAB) {\n    return;\n  }\n\n  if (silent) {\n    return true;\n  }\n\n  index = 0;\n  items = [];\n  allLines = [];\n  emptyLines = [];\n\n  while (index < length) {\n    nextIndex = value.indexOf(C_NEWLINE, index);\n    startIndex = index;\n    prefixed = false;\n    indented = false;\n\n    if (nextIndex === -1) {\n      nextIndex = length;\n    }\n\n    end = index + TAB_SIZE;\n    size = 0;\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character === C_TAB) {\n        size += TAB_SIZE - (size % TAB_SIZE);\n      } else if (character === C_SPACE) {\n        size++;\n      } else {\n        break;\n      }\n\n      index++;\n    }\n\n    if (size >= TAB_SIZE) {\n      indented = true;\n    }\n\n    if (item && size >= item.indent) {\n      indented = true;\n    }\n\n    character = value.charAt(index);\n    currentMarker = null;\n\n    if (!indented) {\n      if (LIST_UNORDERED_MARKERS[character] === true) {\n        currentMarker = character;\n        index++;\n        size++;\n      } else {\n        queue = '';\n\n        while (index < length) {\n          character = value.charAt(index);\n\n          if (!decimal(character)) {\n            break;\n          }\n\n          queue += character;\n          index++;\n        }\n\n        character = value.charAt(index);\n        index++;\n\n        if (queue && markers[character] === true) {\n          currentMarker = character;\n          size += queue.length + 1;\n        }\n      }\n\n      if (currentMarker) {\n        character = value.charAt(index);\n\n        if (character === C_TAB) {\n          size += TAB_SIZE - (size % TAB_SIZE);\n          index++;\n        } else if (character === C_SPACE) {\n          end = index + TAB_SIZE;\n\n          while (index < end) {\n            if (value.charAt(index) !== C_SPACE) {\n              break;\n            }\n\n            index++;\n            size++;\n          }\n\n          if (index === end && value.charAt(index) === C_SPACE) {\n            index -= TAB_SIZE - 1;\n            size -= TAB_SIZE - 1;\n          }\n        } else if (character !== C_NEWLINE && character !== '') {\n          currentMarker = null;\n        }\n      }\n    }\n\n    if (currentMarker) {\n      if (!pedantic && marker !== currentMarker) {\n        break;\n      }\n\n      prefixed = true;\n    } else {\n      if (!commonmark && !indented && value.charAt(startIndex) === C_SPACE) {\n        indented = true;\n      } else if (commonmark && item) {\n        indented = size >= item.indent || size > TAB_SIZE;\n      }\n\n      prefixed = false;\n      index = startIndex;\n    }\n\n    line = value.slice(startIndex, nextIndex);\n    content = startIndex === index ? line : value.slice(index, nextIndex);\n\n    if (\n      currentMarker === C_ASTERISK ||\n      currentMarker === C_UNDERSCORE ||\n      currentMarker === C_DASH\n    ) {\n      if (tokenizers.thematicBreak.call(self, eat, line, true)) {\n        break;\n      }\n    }\n\n    prevEmpty = empty;\n    empty = !trim(content).length;\n\n    if (indented && item) {\n      item.value = item.value.concat(emptyLines, line);\n      allLines = allLines.concat(emptyLines, line);\n      emptyLines = [];\n    } else if (prefixed) {\n      if (emptyLines.length !== 0) {\n        item.value.push('');\n        item.trail = emptyLines.concat();\n      }\n\n      item = {\n        value: [line],\n        indent: size,\n        trail: []\n      };\n\n      items.push(item);\n      allLines = allLines.concat(emptyLines, line);\n      emptyLines = [];\n    } else if (empty) {\n      if (prevEmpty) {\n        break;\n      }\n\n      emptyLines.push(line);\n    } else {\n      if (prevEmpty) {\n        break;\n      }\n\n      if (interrupt(interuptors, tokenizers, self, [eat, line, true])) {\n        break;\n      }\n\n      item.value = item.value.concat(emptyLines, line);\n      allLines = allLines.concat(emptyLines, line);\n      emptyLines = [];\n    }\n\n    index = nextIndex + 1;\n  }\n\n  node = eat(allLines.join(C_NEWLINE)).reset({\n    type: 'list',\n    ordered: ordered,\n    start: start,\n    loose: null,\n    children: []\n  });\n\n  enterTop = self.enterList();\n  exitBlockquote = self.enterBlock();\n  isLoose = false;\n  index = -1;\n  length = items.length;\n\n  while (++index < length) {\n    item = items[index].value.join(C_NEWLINE);\n    now = eat.now();\n\n    item = eat(item)(listItem(self, item, now), node);\n\n    if (item.loose) {\n      isLoose = true;\n    }\n\n    item = items[index].trail.join(C_NEWLINE);\n\n    if (index !== length - 1) {\n      item += C_NEWLINE;\n    }\n\n    eat(item);\n  }\n\n  enterTop();\n  exitBlockquote();\n\n  node.loose = isLoose;\n\n  return node;\n}\n\nfunction listItem(ctx, value, position) {\n  var offsets = ctx.offset;\n  var fn = ctx.options.pedantic ? pedanticListItem : normalListItem;\n  var checked = null;\n  var task;\n  var indent;\n\n  value = fn.apply(null, arguments);\n\n  if (ctx.options.gfm) {\n    task = value.match(EXPRESSION_TASK_ITEM);\n\n    if (task) {\n      indent = task[0].length;\n      checked = task[1].toLowerCase() === C_X_LOWER;\n      offsets[position.line] += indent;\n      value = value.slice(indent);\n    }\n  }\n\n  return {\n    type: 'listItem',\n    loose: EXPRESSION_LOOSE_LIST_ITEM.test(value) ||\n      value.charAt(value.length - 1) === C_NEWLINE,\n    checked: checked,\n    children: ctx.tokenizeBlock(value, position)\n  };\n}\n\n/* Create a list-item using overly simple mechanics. */\nfunction pedanticListItem(ctx, value, position) {\n  var offsets = ctx.offset;\n  var line = position.line;\n\n  /* Remove the list-item’s bullet. */\n  value = value.replace(EXPRESSION_PEDANTIC_BULLET, replacer);\n\n  /* The initial line was also matched by the below, so\n   * we reset the `line`. */\n  line = position.line;\n\n  return value.replace(EXPRESSION_INITIAL_INDENT, replacer);\n\n  /* A simple replacer which removed all matches,\n   * and adds their length to `offset`. */\n  function replacer($0) {\n    offsets[line] = (offsets[line] || 0) + $0.length;\n    line++;\n\n    return '';\n  }\n}\n\n/* Create a list-item using sane mechanics. */\nfunction normalListItem(ctx, value, position) {\n  var offsets = ctx.offset;\n  var line = position.line;\n  var max;\n  var bullet;\n  var rest;\n  var lines;\n  var trimmedLines;\n  var index;\n  var length;\n\n  /* Remove the list-item’s bullet. */\n  value = value.replace(EXPRESSION_BULLET, replacer);\n\n  lines = value.split(C_NEWLINE);\n\n  trimmedLines = removeIndent(value, getIndent(max).indent).split(C_NEWLINE);\n\n  /* We replaced the initial bullet with something\n   * else above, which was used to trick\n   * `removeIndentation` into removing some more\n   * characters when possible.  However, that could\n   * result in the initial line to be stripped more\n   * than it should be. */\n  trimmedLines[0] = rest;\n\n  offsets[line] = (offsets[line] || 0) + bullet.length;\n  line++;\n\n  index = 0;\n  length = lines.length;\n\n  while (++index < length) {\n    offsets[line] = (offsets[line] || 0) +\n      lines[index].length - trimmedLines[index].length;\n    line++;\n  }\n\n  return trimmedLines.join(C_NEWLINE);\n\n  function replacer($0, $1, $2, $3, $4) {\n    bullet = $1 + $2 + $3;\n    rest = $4;\n\n    /* Make sure that the first nine numbered list items\n     * can indent with an extra space.  That is, when\n     * the bullet did not receive an extra final space. */\n    if (Number($2) < 10 && bullet.length % 2 === 1) {\n      $2 = C_SPACE + $2;\n    }\n\n    max = $1 + repeat(C_SPACE, $2.length) + $3;\n\n    return max + rest;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}