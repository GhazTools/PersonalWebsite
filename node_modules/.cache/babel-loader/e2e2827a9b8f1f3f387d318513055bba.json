{"ast":null,"code":"'use strict';\n\nvar trim = require('trim-trailing-lines');\n\nmodule.exports = fencedCode;\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar C_SPACE = ' ';\nvar C_TILDE = '~';\nvar C_TICK = '`';\nvar MIN_FENCE_COUNT = 3;\nvar CODE_INDENT_COUNT = 4;\n\nfunction fencedCode(eat, value, silent) {\n  var self = this;\n  var settings = self.options;\n  var length = value.length + 1;\n  var index = 0;\n  var subvalue = '';\n  var fenceCount;\n  var marker;\n  var character;\n  var flag;\n  var queue;\n  var content;\n  var exdentedContent;\n  var closing;\n  var exdentedClosing;\n  var indent;\n  var now;\n\n  if (!settings.gfm) {\n    return;\n  }\n  /* Eat initial spacing. */\n\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_SPACE && character !== C_TAB) {\n      break;\n    }\n\n    subvalue += character;\n    index++;\n  }\n\n  indent = index;\n  /* Eat the fence. */\n\n  character = value.charAt(index);\n\n  if (character !== C_TILDE && character !== C_TICK) {\n    return;\n  }\n\n  index++;\n  marker = character;\n  fenceCount = 1;\n  subvalue += character;\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== marker) {\n      break;\n    }\n\n    subvalue += character;\n    fenceCount++;\n    index++;\n  }\n\n  if (fenceCount < MIN_FENCE_COUNT) {\n    return;\n  }\n  /* Eat spacing before flag. */\n\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_SPACE && character !== C_TAB) {\n      break;\n    }\n\n    subvalue += character;\n    index++;\n  }\n  /* Eat flag. */\n\n\n  flag = '';\n  queue = '';\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character === C_NEWLINE || character === C_TILDE || character === C_TICK) {\n      break;\n    }\n\n    if (character === C_SPACE || character === C_TAB) {\n      queue += character;\n    } else {\n      flag += queue + character;\n      queue = '';\n    }\n\n    index++;\n  }\n\n  character = value.charAt(index);\n\n  if (character && character !== C_NEWLINE) {\n    return;\n  }\n\n  if (silent) {\n    return true;\n  }\n\n  now = eat.now();\n  now.column += subvalue.length;\n  now.offset += subvalue.length;\n  subvalue += flag;\n  flag = self.decode.raw(self.unescape(flag), now);\n\n  if (queue) {\n    subvalue += queue;\n  }\n\n  queue = '';\n  closing = '';\n  exdentedClosing = '';\n  content = '';\n  exdentedContent = '';\n  /* Eat content. */\n\n  while (index < length) {\n    character = value.charAt(index);\n    content += closing;\n    exdentedContent += exdentedClosing;\n    closing = '';\n    exdentedClosing = '';\n\n    if (character !== C_NEWLINE) {\n      content += character;\n      exdentedClosing += character;\n      index++;\n      continue;\n    }\n    /* Add the newline to `subvalue` if its the first\n     * character.  Otherwise, add it to the `closing`\n     * queue. */\n\n\n    if (content) {\n      closing += character;\n      exdentedClosing += character;\n    } else {\n      subvalue += character;\n    }\n\n    queue = '';\n    index++;\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character !== C_SPACE) {\n        break;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    closing += queue;\n    exdentedClosing += queue.slice(indent);\n\n    if (queue.length >= CODE_INDENT_COUNT) {\n      continue;\n    }\n\n    queue = '';\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character !== marker) {\n        break;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    closing += queue;\n    exdentedClosing += queue;\n\n    if (queue.length < fenceCount) {\n      continue;\n    }\n\n    queue = '';\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character !== C_SPACE && character !== C_TAB) {\n        break;\n      }\n\n      closing += character;\n      exdentedClosing += character;\n      index++;\n    }\n\n    if (!character || character === C_NEWLINE) {\n      break;\n    }\n  }\n\n  subvalue += content + closing;\n  return eat(subvalue)({\n    type: 'code',\n    lang: flag || null,\n    value: trim(exdentedContent)\n  });\n}","map":{"version":3,"names":["trim","require","module","exports","fencedCode","C_NEWLINE","C_TAB","C_SPACE","C_TILDE","C_TICK","MIN_FENCE_COUNT","CODE_INDENT_COUNT","eat","value","silent","self","settings","options","length","index","subvalue","fenceCount","marker","character","flag","queue","content","exdentedContent","closing","exdentedClosing","indent","now","gfm","charAt","column","offset","decode","raw","unescape","slice","type","lang"],"sources":["/home/ghaz/personal_website/node_modules/remark-parse/lib/tokenize/code-fenced.js"],"sourcesContent":["'use strict';\n\nvar trim = require('trim-trailing-lines');\n\nmodule.exports = fencedCode;\n\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar C_SPACE = ' ';\nvar C_TILDE = '~';\nvar C_TICK = '`';\n\nvar MIN_FENCE_COUNT = 3;\nvar CODE_INDENT_COUNT = 4;\n\nfunction fencedCode(eat, value, silent) {\n  var self = this;\n  var settings = self.options;\n  var length = value.length + 1;\n  var index = 0;\n  var subvalue = '';\n  var fenceCount;\n  var marker;\n  var character;\n  var flag;\n  var queue;\n  var content;\n  var exdentedContent;\n  var closing;\n  var exdentedClosing;\n  var indent;\n  var now;\n\n  if (!settings.gfm) {\n    return;\n  }\n\n  /* Eat initial spacing. */\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_SPACE && character !== C_TAB) {\n      break;\n    }\n\n    subvalue += character;\n    index++;\n  }\n\n  indent = index;\n\n  /* Eat the fence. */\n  character = value.charAt(index);\n\n  if (character !== C_TILDE && character !== C_TICK) {\n    return;\n  }\n\n  index++;\n  marker = character;\n  fenceCount = 1;\n  subvalue += character;\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== marker) {\n      break;\n    }\n\n    subvalue += character;\n    fenceCount++;\n    index++;\n  }\n\n  if (fenceCount < MIN_FENCE_COUNT) {\n    return;\n  }\n\n  /* Eat spacing before flag. */\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_SPACE && character !== C_TAB) {\n      break;\n    }\n\n    subvalue += character;\n    index++;\n  }\n\n  /* Eat flag. */\n  flag = '';\n  queue = '';\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (\n      character === C_NEWLINE ||\n      character === C_TILDE ||\n      character === C_TICK\n    ) {\n      break;\n    }\n\n    if (character === C_SPACE || character === C_TAB) {\n      queue += character;\n    } else {\n      flag += queue + character;\n      queue = '';\n    }\n\n    index++;\n  }\n\n  character = value.charAt(index);\n\n  if (character && character !== C_NEWLINE) {\n    return;\n  }\n\n  if (silent) {\n    return true;\n  }\n\n  now = eat.now();\n  now.column += subvalue.length;\n  now.offset += subvalue.length;\n\n  subvalue += flag;\n  flag = self.decode.raw(self.unescape(flag), now);\n\n  if (queue) {\n    subvalue += queue;\n  }\n\n  queue = '';\n  closing = '';\n  exdentedClosing = '';\n  content = '';\n  exdentedContent = '';\n\n  /* Eat content. */\n  while (index < length) {\n    character = value.charAt(index);\n    content += closing;\n    exdentedContent += exdentedClosing;\n    closing = '';\n    exdentedClosing = '';\n\n    if (character !== C_NEWLINE) {\n      content += character;\n      exdentedClosing += character;\n      index++;\n      continue;\n    }\n\n    /* Add the newline to `subvalue` if its the first\n     * character.  Otherwise, add it to the `closing`\n     * queue. */\n    if (content) {\n      closing += character;\n      exdentedClosing += character;\n    } else {\n      subvalue += character;\n    }\n\n    queue = '';\n    index++;\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character !== C_SPACE) {\n        break;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    closing += queue;\n    exdentedClosing += queue.slice(indent);\n\n    if (queue.length >= CODE_INDENT_COUNT) {\n      continue;\n    }\n\n    queue = '';\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character !== marker) {\n        break;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    closing += queue;\n    exdentedClosing += queue;\n\n    if (queue.length < fenceCount) {\n      continue;\n    }\n\n    queue = '';\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character !== C_SPACE && character !== C_TAB) {\n        break;\n      }\n\n      closing += character;\n      exdentedClosing += character;\n      index++;\n    }\n\n    if (!character || character === C_NEWLINE) {\n      break;\n    }\n  }\n\n  subvalue += content + closing;\n\n  return eat(subvalue)({\n    type: 'code',\n    lang: flag || null,\n    value: trim(exdentedContent)\n  });\n}\n"],"mappings":"AAAA;;AAEA,IAAIA,IAAI,GAAGC,OAAO,CAAC,qBAAD,CAAlB;;AAEAC,MAAM,CAACC,OAAP,GAAiBC,UAAjB;AAEA,IAAIC,SAAS,GAAG,IAAhB;AACA,IAAIC,KAAK,GAAG,IAAZ;AACA,IAAIC,OAAO,GAAG,GAAd;AACA,IAAIC,OAAO,GAAG,GAAd;AACA,IAAIC,MAAM,GAAG,GAAb;AAEA,IAAIC,eAAe,GAAG,CAAtB;AACA,IAAIC,iBAAiB,GAAG,CAAxB;;AAEA,SAASP,UAAT,CAAoBQ,GAApB,EAAyBC,KAAzB,EAAgCC,MAAhC,EAAwC;EACtC,IAAIC,IAAI,GAAG,IAAX;EACA,IAAIC,QAAQ,GAAGD,IAAI,CAACE,OAApB;EACA,IAAIC,MAAM,GAAGL,KAAK,CAACK,MAAN,GAAe,CAA5B;EACA,IAAIC,KAAK,GAAG,CAAZ;EACA,IAAIC,QAAQ,GAAG,EAAf;EACA,IAAIC,UAAJ;EACA,IAAIC,MAAJ;EACA,IAAIC,SAAJ;EACA,IAAIC,IAAJ;EACA,IAAIC,KAAJ;EACA,IAAIC,OAAJ;EACA,IAAIC,eAAJ;EACA,IAAIC,OAAJ;EACA,IAAIC,eAAJ;EACA,IAAIC,MAAJ;EACA,IAAIC,GAAJ;;EAEA,IAAI,CAACf,QAAQ,CAACgB,GAAd,EAAmB;IACjB;EACD;EAED;;;EACA,OAAOb,KAAK,GAAGD,MAAf,EAAuB;IACrBK,SAAS,GAAGV,KAAK,CAACoB,MAAN,CAAad,KAAb,CAAZ;;IAEA,IAAII,SAAS,KAAKhB,OAAd,IAAyBgB,SAAS,KAAKjB,KAA3C,EAAkD;MAChD;IACD;;IAEDc,QAAQ,IAAIG,SAAZ;IACAJ,KAAK;EACN;;EAEDW,MAAM,GAAGX,KAAT;EAEA;;EACAI,SAAS,GAAGV,KAAK,CAACoB,MAAN,CAAad,KAAb,CAAZ;;EAEA,IAAII,SAAS,KAAKf,OAAd,IAAyBe,SAAS,KAAKd,MAA3C,EAAmD;IACjD;EACD;;EAEDU,KAAK;EACLG,MAAM,GAAGC,SAAT;EACAF,UAAU,GAAG,CAAb;EACAD,QAAQ,IAAIG,SAAZ;;EAEA,OAAOJ,KAAK,GAAGD,MAAf,EAAuB;IACrBK,SAAS,GAAGV,KAAK,CAACoB,MAAN,CAAad,KAAb,CAAZ;;IAEA,IAAII,SAAS,KAAKD,MAAlB,EAA0B;MACxB;IACD;;IAEDF,QAAQ,IAAIG,SAAZ;IACAF,UAAU;IACVF,KAAK;EACN;;EAED,IAAIE,UAAU,GAAGX,eAAjB,EAAkC;IAChC;EACD;EAED;;;EACA,OAAOS,KAAK,GAAGD,MAAf,EAAuB;IACrBK,SAAS,GAAGV,KAAK,CAACoB,MAAN,CAAad,KAAb,CAAZ;;IAEA,IAAII,SAAS,KAAKhB,OAAd,IAAyBgB,SAAS,KAAKjB,KAA3C,EAAkD;MAChD;IACD;;IAEDc,QAAQ,IAAIG,SAAZ;IACAJ,KAAK;EACN;EAED;;;EACAK,IAAI,GAAG,EAAP;EACAC,KAAK,GAAG,EAAR;;EAEA,OAAON,KAAK,GAAGD,MAAf,EAAuB;IACrBK,SAAS,GAAGV,KAAK,CAACoB,MAAN,CAAad,KAAb,CAAZ;;IAEA,IACEI,SAAS,KAAKlB,SAAd,IACAkB,SAAS,KAAKf,OADd,IAEAe,SAAS,KAAKd,MAHhB,EAIE;MACA;IACD;;IAED,IAAIc,SAAS,KAAKhB,OAAd,IAAyBgB,SAAS,KAAKjB,KAA3C,EAAkD;MAChDmB,KAAK,IAAIF,SAAT;IACD,CAFD,MAEO;MACLC,IAAI,IAAIC,KAAK,GAAGF,SAAhB;MACAE,KAAK,GAAG,EAAR;IACD;;IAEDN,KAAK;EACN;;EAEDI,SAAS,GAAGV,KAAK,CAACoB,MAAN,CAAad,KAAb,CAAZ;;EAEA,IAAII,SAAS,IAAIA,SAAS,KAAKlB,SAA/B,EAA0C;IACxC;EACD;;EAED,IAAIS,MAAJ,EAAY;IACV,OAAO,IAAP;EACD;;EAEDiB,GAAG,GAAGnB,GAAG,CAACmB,GAAJ,EAAN;EACAA,GAAG,CAACG,MAAJ,IAAcd,QAAQ,CAACF,MAAvB;EACAa,GAAG,CAACI,MAAJ,IAAcf,QAAQ,CAACF,MAAvB;EAEAE,QAAQ,IAAII,IAAZ;EACAA,IAAI,GAAGT,IAAI,CAACqB,MAAL,CAAYC,GAAZ,CAAgBtB,IAAI,CAACuB,QAAL,CAAcd,IAAd,CAAhB,EAAqCO,GAArC,CAAP;;EAEA,IAAIN,KAAJ,EAAW;IACTL,QAAQ,IAAIK,KAAZ;EACD;;EAEDA,KAAK,GAAG,EAAR;EACAG,OAAO,GAAG,EAAV;EACAC,eAAe,GAAG,EAAlB;EACAH,OAAO,GAAG,EAAV;EACAC,eAAe,GAAG,EAAlB;EAEA;;EACA,OAAOR,KAAK,GAAGD,MAAf,EAAuB;IACrBK,SAAS,GAAGV,KAAK,CAACoB,MAAN,CAAad,KAAb,CAAZ;IACAO,OAAO,IAAIE,OAAX;IACAD,eAAe,IAAIE,eAAnB;IACAD,OAAO,GAAG,EAAV;IACAC,eAAe,GAAG,EAAlB;;IAEA,IAAIN,SAAS,KAAKlB,SAAlB,EAA6B;MAC3BqB,OAAO,IAAIH,SAAX;MACAM,eAAe,IAAIN,SAAnB;MACAJ,KAAK;MACL;IACD;IAED;AACJ;AACA;;;IACI,IAAIO,OAAJ,EAAa;MACXE,OAAO,IAAIL,SAAX;MACAM,eAAe,IAAIN,SAAnB;IACD,CAHD,MAGO;MACLH,QAAQ,IAAIG,SAAZ;IACD;;IAEDE,KAAK,GAAG,EAAR;IACAN,KAAK;;IAEL,OAAOA,KAAK,GAAGD,MAAf,EAAuB;MACrBK,SAAS,GAAGV,KAAK,CAACoB,MAAN,CAAad,KAAb,CAAZ;;MAEA,IAAII,SAAS,KAAKhB,OAAlB,EAA2B;QACzB;MACD;;MAEDkB,KAAK,IAAIF,SAAT;MACAJ,KAAK;IACN;;IAEDS,OAAO,IAAIH,KAAX;IACAI,eAAe,IAAIJ,KAAK,CAACc,KAAN,CAAYT,MAAZ,CAAnB;;IAEA,IAAIL,KAAK,CAACP,MAAN,IAAgBP,iBAApB,EAAuC;MACrC;IACD;;IAEDc,KAAK,GAAG,EAAR;;IAEA,OAAON,KAAK,GAAGD,MAAf,EAAuB;MACrBK,SAAS,GAAGV,KAAK,CAACoB,MAAN,CAAad,KAAb,CAAZ;;MAEA,IAAII,SAAS,KAAKD,MAAlB,EAA0B;QACxB;MACD;;MAEDG,KAAK,IAAIF,SAAT;MACAJ,KAAK;IACN;;IAEDS,OAAO,IAAIH,KAAX;IACAI,eAAe,IAAIJ,KAAnB;;IAEA,IAAIA,KAAK,CAACP,MAAN,GAAeG,UAAnB,EAA+B;MAC7B;IACD;;IAEDI,KAAK,GAAG,EAAR;;IAEA,OAAON,KAAK,GAAGD,MAAf,EAAuB;MACrBK,SAAS,GAAGV,KAAK,CAACoB,MAAN,CAAad,KAAb,CAAZ;;MAEA,IAAII,SAAS,KAAKhB,OAAd,IAAyBgB,SAAS,KAAKjB,KAA3C,EAAkD;QAChD;MACD;;MAEDsB,OAAO,IAAIL,SAAX;MACAM,eAAe,IAAIN,SAAnB;MACAJ,KAAK;IACN;;IAED,IAAI,CAACI,SAAD,IAAcA,SAAS,KAAKlB,SAAhC,EAA2C;MACzC;IACD;EACF;;EAEDe,QAAQ,IAAIM,OAAO,GAAGE,OAAtB;EAEA,OAAOhB,GAAG,CAACQ,QAAD,CAAH,CAAc;IACnBoB,IAAI,EAAE,MADa;IAEnBC,IAAI,EAAEjB,IAAI,IAAI,IAFK;IAGnBX,KAAK,EAAEb,IAAI,CAAC2B,eAAD;EAHQ,CAAd,CAAP;AAKD"},"metadata":{},"sourceType":"script"}