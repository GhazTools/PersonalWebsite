{"ast":null,"code":"'use strict';\n\nmodule.exports = factory;\nvar MERGEABLE_NODES = {\n  text: mergeText,\n  blockquote: mergeBlockquote\n};\n/* Check whether a node is mergeable with adjacent nodes. */\n\nfunction mergeable(node) {\n  var start;\n  var end;\n\n  if (node.type !== 'text' || !node.position) {\n    return true;\n  }\n\n  start = node.position.start;\n  end = node.position.end;\n  /* Only merge nodes which occupy the same size as their\n   * `value`. */\n\n  return start.line !== end.line || end.column - start.column === node.value.length;\n}\n/* Merge two text nodes: `node` into `prev`. */\n\n\nfunction mergeText(prev, node) {\n  prev.value += node.value;\n  return prev;\n}\n/* Merge two blockquotes: `node` into `prev`, unless in\n * CommonMark mode. */\n\n\nfunction mergeBlockquote(prev, node) {\n  if (this.options.commonmark) {\n    return node;\n  }\n\n  prev.children = prev.children.concat(node.children);\n  return prev;\n}\n/* Construct a tokenizer.  This creates both\n * `tokenizeInline` and `tokenizeBlock`. */\n\n\nfunction factory(type) {\n  return tokenize;\n  /* Tokenizer for a bound `type`. */\n\n  function tokenize(value, location) {\n    var self = this;\n    var offset = self.offset;\n    var tokens = [];\n    var methods = self[type + 'Methods'];\n    var tokenizers = self[type + 'Tokenizers'];\n    var line = location.line;\n    var column = location.column;\n    var index;\n    var length;\n    var method;\n    var name;\n    var matched;\n    var valueLength;\n    /* Trim white space only lines. */\n\n    if (!value) {\n      return tokens;\n    }\n    /* Expose on `eat`. */\n\n\n    eat.now = now;\n    eat.file = self.file;\n    /* Sync initial offset. */\n\n    updatePosition('');\n    /* Iterate over `value`, and iterate over all\n     * tokenizers.  When one eats something, re-iterate\n     * with the remaining value.  If no tokenizer eats,\n     * something failed (should not happen) and an\n     * exception is thrown. */\n\n    while (value) {\n      index = -1;\n      length = methods.length;\n      matched = false;\n\n      while (++index < length) {\n        name = methods[index];\n        method = tokenizers[name];\n\n        if (method && (\n        /* istanbul ignore next */\n        !method.onlyAtStart || self.atStart) && (!method.notInList || !self.inList) && (!method.notInBlock || !self.inBlock) && (!method.notInLink || !self.inLink)) {\n          valueLength = value.length;\n          method.apply(self, [eat, value]);\n          matched = valueLength !== value.length;\n\n          if (matched) {\n            break;\n          }\n        }\n      }\n      /* istanbul ignore if */\n\n\n      if (!matched) {\n        self.file.fail(new Error('Infinite loop'), eat.now());\n      }\n    }\n\n    self.eof = now();\n    return tokens;\n    /* Update line, column, and offset based on\n     * `value`. */\n\n    function updatePosition(subvalue) {\n      var lastIndex = -1;\n      var index = subvalue.indexOf('\\n');\n\n      while (index !== -1) {\n        line++;\n        lastIndex = index;\n        index = subvalue.indexOf('\\n', index + 1);\n      }\n\n      if (lastIndex === -1) {\n        column += subvalue.length;\n      } else {\n        column = subvalue.length - lastIndex;\n      }\n\n      if (line in offset) {\n        if (lastIndex !== -1) {\n          column += offset[line];\n        } else if (column <= offset[line]) {\n          column = offset[line] + 1;\n        }\n      }\n    }\n    /* Get offset.  Called before the first character is\n     * eaten to retrieve the range's offsets. */\n\n\n    function getOffset() {\n      var indentation = [];\n      var pos = line + 1;\n      /* Done.  Called when the last character is\n       * eaten to retrieve the range’s offsets. */\n\n      return function () {\n        var last = line + 1;\n\n        while (pos < last) {\n          indentation.push((offset[pos] || 0) + 1);\n          pos++;\n        }\n\n        return indentation;\n      };\n    }\n    /* Get the current position. */\n\n\n    function now() {\n      var pos = {\n        line: line,\n        column: column\n      };\n      pos.offset = self.toOffset(pos);\n      return pos;\n    }\n    /* Store position information for a node. */\n\n\n    function Position(start) {\n      this.start = start;\n      this.end = now();\n    }\n    /* Throw when a value is incorrectly eaten.\n     * This shouldn’t happen but will throw on new,\n     * incorrect rules. */\n\n\n    function validateEat(subvalue) {\n      /* istanbul ignore if */\n      if (value.substring(0, subvalue.length) !== subvalue) {\n        /* Capture stack-trace. */\n        self.file.fail(new Error('Incorrectly eaten value: please report this ' + 'warning on http://git.io/vg5Ft'), now());\n      }\n    }\n    /* Mark position and patch `node.position`. */\n\n\n    function position() {\n      var before = now();\n      return update;\n      /* Add the position to a node. */\n\n      function update(node, indent) {\n        var prev = node.position;\n        var start = prev ? prev.start : before;\n        var combined = [];\n        var n = prev && prev.end.line;\n        var l = before.line;\n        node.position = new Position(start);\n        /* If there was already a `position`, this\n         * node was merged.  Fixing `start` wasn’t\n         * hard, but the indent is different.\n         * Especially because some information, the\n         * indent between `n` and `l` wasn’t\n         * tracked.  Luckily, that space is\n         * (should be?) empty, so we can safely\n         * check for it now. */\n\n        if (prev && indent && prev.indent) {\n          combined = prev.indent;\n\n          if (n < l) {\n            while (++n < l) {\n              combined.push((offset[n] || 0) + 1);\n            }\n\n            combined.push(before.column);\n          }\n\n          indent = combined.concat(indent);\n        }\n\n        node.position.indent = indent || [];\n        return node;\n      }\n    }\n    /* Add `node` to `parent`s children or to `tokens`.\n     * Performs merges where possible. */\n\n\n    function add(node, parent) {\n      var children = parent ? parent.children : tokens;\n      var prev = children[children.length - 1];\n\n      if (prev && node.type === prev.type && node.type in MERGEABLE_NODES && mergeable(prev) && mergeable(node)) {\n        node = MERGEABLE_NODES[node.type].call(self, prev, node);\n      }\n\n      if (node !== prev) {\n        children.push(node);\n      }\n\n      if (self.atStart && tokens.length !== 0) {\n        self.exitStart();\n      }\n\n      return node;\n    }\n    /* Remove `subvalue` from `value`.\n     * `subvalue` must be at the start of `value`. */\n\n\n    function eat(subvalue) {\n      var indent = getOffset();\n      var pos = position();\n      var current = now();\n      validateEat(subvalue);\n      apply.reset = reset;\n      reset.test = test;\n      apply.test = test;\n      value = value.substring(subvalue.length);\n      updatePosition(subvalue);\n      indent = indent();\n      return apply;\n      /* Add the given arguments, add `position` to\n       * the returned node, and return the node. */\n\n      function apply(node, parent) {\n        return pos(add(pos(node), parent), indent);\n      }\n      /* Functions just like apply, but resets the\n       * content:  the line and column are reversed,\n       * and the eaten value is re-added.\n       * This is useful for nodes with a single\n       * type of content, such as lists and tables.\n       * See `apply` above for what parameters are\n       * expected. */\n\n\n      function reset() {\n        var node = apply.apply(null, arguments);\n        line = current.line;\n        column = current.column;\n        value = subvalue + value;\n        return node;\n      }\n      /* Test the position, after eating, and reverse\n       * to a not-eaten state. */\n\n\n      function test() {\n        var result = pos({});\n        line = current.line;\n        column = current.column;\n        value = subvalue + value;\n        return result.position;\n      }\n    }\n  }\n}","map":{"version":3,"names":["module","exports","factory","MERGEABLE_NODES","text","mergeText","blockquote","mergeBlockquote","mergeable","node","start","end","type","position","line","column","value","length","prev","options","commonmark","children","concat","tokenize","location","self","offset","tokens","methods","tokenizers","index","method","name","matched","valueLength","eat","now","file","updatePosition","onlyAtStart","atStart","notInList","inList","notInBlock","inBlock","notInLink","inLink","apply","fail","Error","eof","subvalue","lastIndex","indexOf","getOffset","indentation","pos","last","push","toOffset","Position","validateEat","substring","before","update","indent","combined","n","l","add","parent","call","exitStart","current","reset","test","arguments","result"],"sources":["/home/ghaz/PersonalWebsite/node_modules/remark-parse/lib/tokenizer.js"],"sourcesContent":["'use strict';\n\nmodule.exports = factory;\n\nvar MERGEABLE_NODES = {\n  text: mergeText,\n  blockquote: mergeBlockquote\n};\n\n/* Check whether a node is mergeable with adjacent nodes. */\nfunction mergeable(node) {\n  var start;\n  var end;\n\n  if (node.type !== 'text' || !node.position) {\n    return true;\n  }\n\n  start = node.position.start;\n  end = node.position.end;\n\n  /* Only merge nodes which occupy the same size as their\n   * `value`. */\n  return start.line !== end.line ||\n      end.column - start.column === node.value.length;\n}\n\n/* Merge two text nodes: `node` into `prev`. */\nfunction mergeText(prev, node) {\n  prev.value += node.value;\n\n  return prev;\n}\n\n/* Merge two blockquotes: `node` into `prev`, unless in\n * CommonMark mode. */\nfunction mergeBlockquote(prev, node) {\n  if (this.options.commonmark) {\n    return node;\n  }\n\n  prev.children = prev.children.concat(node.children);\n\n  return prev;\n}\n\n/* Construct a tokenizer.  This creates both\n * `tokenizeInline` and `tokenizeBlock`. */\nfunction factory(type) {\n  return tokenize;\n\n  /* Tokenizer for a bound `type`. */\n  function tokenize(value, location) {\n    var self = this;\n    var offset = self.offset;\n    var tokens = [];\n    var methods = self[type + 'Methods'];\n    var tokenizers = self[type + 'Tokenizers'];\n    var line = location.line;\n    var column = location.column;\n    var index;\n    var length;\n    var method;\n    var name;\n    var matched;\n    var valueLength;\n\n    /* Trim white space only lines. */\n    if (!value) {\n      return tokens;\n    }\n\n    /* Expose on `eat`. */\n    eat.now = now;\n    eat.file = self.file;\n\n    /* Sync initial offset. */\n    updatePosition('');\n\n    /* Iterate over `value`, and iterate over all\n     * tokenizers.  When one eats something, re-iterate\n     * with the remaining value.  If no tokenizer eats,\n     * something failed (should not happen) and an\n     * exception is thrown. */\n    while (value) {\n      index = -1;\n      length = methods.length;\n      matched = false;\n\n      while (++index < length) {\n        name = methods[index];\n        method = tokenizers[name];\n\n        if (\n          method &&\n          /* istanbul ignore next */ (!method.onlyAtStart || self.atStart) &&\n          (!method.notInList || !self.inList) &&\n          (!method.notInBlock || !self.inBlock) &&\n          (!method.notInLink || !self.inLink)\n        ) {\n          valueLength = value.length;\n\n          method.apply(self, [eat, value]);\n\n          matched = valueLength !== value.length;\n\n          if (matched) {\n            break;\n          }\n        }\n      }\n\n      /* istanbul ignore if */\n      if (!matched) {\n        self.file.fail(new Error('Infinite loop'), eat.now());\n      }\n    }\n\n    self.eof = now();\n\n    return tokens;\n\n    /* Update line, column, and offset based on\n     * `value`. */\n    function updatePosition(subvalue) {\n      var lastIndex = -1;\n      var index = subvalue.indexOf('\\n');\n\n      while (index !== -1) {\n        line++;\n        lastIndex = index;\n        index = subvalue.indexOf('\\n', index + 1);\n      }\n\n      if (lastIndex === -1) {\n        column += subvalue.length;\n      } else {\n        column = subvalue.length - lastIndex;\n      }\n\n      if (line in offset) {\n        if (lastIndex !== -1) {\n          column += offset[line];\n        } else if (column <= offset[line]) {\n          column = offset[line] + 1;\n        }\n      }\n    }\n\n    /* Get offset.  Called before the first character is\n     * eaten to retrieve the range's offsets. */\n    function getOffset() {\n      var indentation = [];\n      var pos = line + 1;\n\n      /* Done.  Called when the last character is\n       * eaten to retrieve the range’s offsets. */\n      return function () {\n        var last = line + 1;\n\n        while (pos < last) {\n          indentation.push((offset[pos] || 0) + 1);\n\n          pos++;\n        }\n\n        return indentation;\n      };\n    }\n\n    /* Get the current position. */\n    function now() {\n      var pos = {line: line, column: column};\n\n      pos.offset = self.toOffset(pos);\n\n      return pos;\n    }\n\n    /* Store position information for a node. */\n    function Position(start) {\n      this.start = start;\n      this.end = now();\n    }\n\n    /* Throw when a value is incorrectly eaten.\n     * This shouldn’t happen but will throw on new,\n     * incorrect rules. */\n    function validateEat(subvalue) {\n      /* istanbul ignore if */\n      if (value.substring(0, subvalue.length) !== subvalue) {\n        /* Capture stack-trace. */\n        self.file.fail(\n          new Error(\n            'Incorrectly eaten value: please report this ' +\n            'warning on http://git.io/vg5Ft'\n          ),\n          now()\n        );\n      }\n    }\n\n    /* Mark position and patch `node.position`. */\n    function position() {\n      var before = now();\n\n      return update;\n\n      /* Add the position to a node. */\n      function update(node, indent) {\n        var prev = node.position;\n        var start = prev ? prev.start : before;\n        var combined = [];\n        var n = prev && prev.end.line;\n        var l = before.line;\n\n        node.position = new Position(start);\n\n        /* If there was already a `position`, this\n         * node was merged.  Fixing `start` wasn’t\n         * hard, but the indent is different.\n         * Especially because some information, the\n         * indent between `n` and `l` wasn’t\n         * tracked.  Luckily, that space is\n         * (should be?) empty, so we can safely\n         * check for it now. */\n        if (prev && indent && prev.indent) {\n          combined = prev.indent;\n\n          if (n < l) {\n            while (++n < l) {\n              combined.push((offset[n] || 0) + 1);\n            }\n\n            combined.push(before.column);\n          }\n\n          indent = combined.concat(indent);\n        }\n\n        node.position.indent = indent || [];\n\n        return node;\n      }\n    }\n\n    /* Add `node` to `parent`s children or to `tokens`.\n     * Performs merges where possible. */\n    function add(node, parent) {\n      var children = parent ? parent.children : tokens;\n      var prev = children[children.length - 1];\n\n      if (\n        prev &&\n        node.type === prev.type &&\n        node.type in MERGEABLE_NODES &&\n        mergeable(prev) &&\n        mergeable(node)\n      ) {\n        node = MERGEABLE_NODES[node.type].call(self, prev, node);\n      }\n\n      if (node !== prev) {\n        children.push(node);\n      }\n\n      if (self.atStart && tokens.length !== 0) {\n        self.exitStart();\n      }\n\n      return node;\n    }\n\n    /* Remove `subvalue` from `value`.\n     * `subvalue` must be at the start of `value`. */\n    function eat(subvalue) {\n      var indent = getOffset();\n      var pos = position();\n      var current = now();\n\n      validateEat(subvalue);\n\n      apply.reset = reset;\n      reset.test = test;\n      apply.test = test;\n\n      value = value.substring(subvalue.length);\n\n      updatePosition(subvalue);\n\n      indent = indent();\n\n      return apply;\n\n      /* Add the given arguments, add `position` to\n       * the returned node, and return the node. */\n      function apply(node, parent) {\n        return pos(add(pos(node), parent), indent);\n      }\n\n      /* Functions just like apply, but resets the\n       * content:  the line and column are reversed,\n       * and the eaten value is re-added.\n       * This is useful for nodes with a single\n       * type of content, such as lists and tables.\n       * See `apply` above for what parameters are\n       * expected. */\n      function reset() {\n        var node = apply.apply(null, arguments);\n\n        line = current.line;\n        column = current.column;\n        value = subvalue + value;\n\n        return node;\n      }\n\n      /* Test the position, after eating, and reverse\n       * to a not-eaten state. */\n      function test() {\n        var result = pos({});\n\n        line = current.line;\n        column = current.column;\n        value = subvalue + value;\n\n        return result.position;\n      }\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}