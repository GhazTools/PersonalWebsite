{"ast":null,"code":"'use strict';\n\nvar whitespace = require('is-whitespace-character');\n\nmodule.exports = table;\nvar C_BACKSLASH = '\\\\';\nvar C_TICK = '`';\nvar C_DASH = '-';\nvar C_PIPE = '|';\nvar C_COLON = ':';\nvar C_SPACE = ' ';\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar MIN_TABLE_COLUMNS = 1;\nvar MIN_TABLE_ROWS = 2;\nvar TABLE_ALIGN_LEFT = 'left';\nvar TABLE_ALIGN_CENTER = 'center';\nvar TABLE_ALIGN_RIGHT = 'right';\nvar TABLE_ALIGN_NONE = null;\n\nfunction table(eat, value, silent) {\n  var self = this;\n  var index;\n  var alignments;\n  var alignment;\n  var subvalue;\n  var row;\n  var length;\n  var lines;\n  var queue;\n  var character;\n  var hasDash;\n  var align;\n  var cell;\n  var preamble;\n  var count;\n  var opening;\n  var now;\n  var position;\n  var lineCount;\n  var line;\n  var rows;\n  var table;\n  var lineIndex;\n  var pipeIndex;\n  var first;\n  /* Exit when not in gfm-mode. */\n\n  if (!self.options.gfm) {\n    return;\n  }\n  /* Get the rows.\n   * Detecting tables soon is hard, so there are some\n   * checks for performance here, such as the minimum\n   * number of rows, and allowed characters in the\n   * alignment row. */\n\n\n  index = 0;\n  lineCount = 0;\n  length = value.length + 1;\n  lines = [];\n\n  while (index < length) {\n    lineIndex = value.indexOf(C_NEWLINE, index);\n    pipeIndex = value.indexOf(C_PIPE, index + 1);\n\n    if (lineIndex === -1) {\n      lineIndex = value.length;\n    }\n\n    if (pipeIndex === -1 || pipeIndex > lineIndex) {\n      if (lineCount < MIN_TABLE_ROWS) {\n        return;\n      }\n\n      break;\n    }\n\n    lines.push(value.slice(index, lineIndex));\n    lineCount++;\n    index = lineIndex + 1;\n  }\n  /* Parse the alignment row. */\n\n\n  subvalue = lines.join(C_NEWLINE);\n  alignments = lines.splice(1, 1)[0] || [];\n  index = 0;\n  length = alignments.length;\n  lineCount--;\n  alignment = false;\n  align = [];\n\n  while (index < length) {\n    character = alignments.charAt(index);\n\n    if (character === C_PIPE) {\n      hasDash = null;\n\n      if (alignment === false) {\n        if (first === false) {\n          return;\n        }\n      } else {\n        align.push(alignment);\n        alignment = false;\n      }\n\n      first = false;\n    } else if (character === C_DASH) {\n      hasDash = true;\n      alignment = alignment || TABLE_ALIGN_NONE;\n    } else if (character === C_COLON) {\n      if (alignment === TABLE_ALIGN_LEFT) {\n        alignment = TABLE_ALIGN_CENTER;\n      } else if (hasDash && alignment === TABLE_ALIGN_NONE) {\n        alignment = TABLE_ALIGN_RIGHT;\n      } else {\n        alignment = TABLE_ALIGN_LEFT;\n      }\n    } else if (!whitespace(character)) {\n      return;\n    }\n\n    index++;\n  }\n\n  if (alignment !== false) {\n    align.push(alignment);\n  }\n  /* Exit when without enough columns. */\n\n\n  if (align.length < MIN_TABLE_COLUMNS) {\n    return;\n  }\n  /* istanbul ignore if - never used (yet) */\n\n\n  if (silent) {\n    return true;\n  }\n  /* Parse the rows. */\n\n\n  position = -1;\n  rows = [];\n  table = eat(subvalue).reset({\n    type: 'table',\n    align: align,\n    children: rows\n  });\n\n  while (++position < lineCount) {\n    line = lines[position];\n    row = {\n      type: 'tableRow',\n      children: []\n    };\n    /* Eat a newline character when this is not the\n     * first row. */\n\n    if (position) {\n      eat(C_NEWLINE);\n    }\n    /* Eat the row. */\n\n\n    eat(line).reset(row, table);\n    length = line.length + 1;\n    index = 0;\n    queue = '';\n    cell = '';\n    preamble = true;\n    count = null;\n    opening = null;\n\n    while (index < length) {\n      character = line.charAt(index);\n\n      if (character === C_TAB || character === C_SPACE) {\n        if (cell) {\n          queue += character;\n        } else {\n          eat(character);\n        }\n\n        index++;\n        continue;\n      }\n\n      if (character === '' || character === C_PIPE) {\n        if (preamble) {\n          eat(character);\n        } else {\n          if (character && opening) {\n            queue += character;\n            index++;\n            continue;\n          }\n\n          if ((cell || character) && !preamble) {\n            subvalue = cell;\n\n            if (queue.length > 1) {\n              if (character) {\n                subvalue += queue.slice(0, queue.length - 1);\n                queue = queue.charAt(queue.length - 1);\n              } else {\n                subvalue += queue;\n                queue = '';\n              }\n            }\n\n            now = eat.now();\n            eat(subvalue)({\n              type: 'tableCell',\n              children: self.tokenizeInline(cell, now)\n            }, row);\n          }\n\n          eat(queue + character);\n          queue = '';\n          cell = '';\n        }\n      } else {\n        if (queue) {\n          cell += queue;\n          queue = '';\n        }\n\n        cell += character;\n\n        if (character === C_BACKSLASH && index !== length - 2) {\n          cell += line.charAt(index + 1);\n          index++;\n        }\n\n        if (character === C_TICK) {\n          count = 1;\n\n          while (line.charAt(index + 1) === character) {\n            cell += character;\n            index++;\n            count++;\n          }\n\n          if (!opening) {\n            opening = count;\n          } else if (count >= opening) {\n            opening = 0;\n          }\n        }\n      }\n\n      preamble = false;\n      index++;\n    }\n    /* Eat the alignment row. */\n\n\n    if (!position) {\n      eat(C_NEWLINE + alignments);\n    }\n  }\n\n  return table;\n}","map":{"version":3,"names":["whitespace","require","module","exports","table","C_BACKSLASH","C_TICK","C_DASH","C_PIPE","C_COLON","C_SPACE","C_NEWLINE","C_TAB","MIN_TABLE_COLUMNS","MIN_TABLE_ROWS","TABLE_ALIGN_LEFT","TABLE_ALIGN_CENTER","TABLE_ALIGN_RIGHT","TABLE_ALIGN_NONE","eat","value","silent","self","index","alignments","alignment","subvalue","row","length","lines","queue","character","hasDash","align","cell","preamble","count","opening","now","position","lineCount","line","rows","lineIndex","pipeIndex","first","options","gfm","indexOf","push","slice","join","splice","charAt","reset","type","children","tokenizeInline"],"sources":["/home/ghaz/PersonalWebsite/node_modules/remark-parse/lib/tokenize/table.js"],"sourcesContent":["'use strict';\n\nvar whitespace = require('is-whitespace-character');\n\nmodule.exports = table;\n\nvar C_BACKSLASH = '\\\\';\nvar C_TICK = '`';\nvar C_DASH = '-';\nvar C_PIPE = '|';\nvar C_COLON = ':';\nvar C_SPACE = ' ';\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\n\nvar MIN_TABLE_COLUMNS = 1;\nvar MIN_TABLE_ROWS = 2;\n\nvar TABLE_ALIGN_LEFT = 'left';\nvar TABLE_ALIGN_CENTER = 'center';\nvar TABLE_ALIGN_RIGHT = 'right';\nvar TABLE_ALIGN_NONE = null;\n\nfunction table(eat, value, silent) {\n  var self = this;\n  var index;\n  var alignments;\n  var alignment;\n  var subvalue;\n  var row;\n  var length;\n  var lines;\n  var queue;\n  var character;\n  var hasDash;\n  var align;\n  var cell;\n  var preamble;\n  var count;\n  var opening;\n  var now;\n  var position;\n  var lineCount;\n  var line;\n  var rows;\n  var table;\n  var lineIndex;\n  var pipeIndex;\n  var first;\n\n  /* Exit when not in gfm-mode. */\n  if (!self.options.gfm) {\n    return;\n  }\n\n  /* Get the rows.\n   * Detecting tables soon is hard, so there are some\n   * checks for performance here, such as the minimum\n   * number of rows, and allowed characters in the\n   * alignment row. */\n  index = 0;\n  lineCount = 0;\n  length = value.length + 1;\n  lines = [];\n\n  while (index < length) {\n    lineIndex = value.indexOf(C_NEWLINE, index);\n    pipeIndex = value.indexOf(C_PIPE, index + 1);\n\n    if (lineIndex === -1) {\n      lineIndex = value.length;\n    }\n\n    if (pipeIndex === -1 || pipeIndex > lineIndex) {\n      if (lineCount < MIN_TABLE_ROWS) {\n        return;\n      }\n\n      break;\n    }\n\n    lines.push(value.slice(index, lineIndex));\n    lineCount++;\n    index = lineIndex + 1;\n  }\n\n  /* Parse the alignment row. */\n  subvalue = lines.join(C_NEWLINE);\n  alignments = lines.splice(1, 1)[0] || [];\n  index = 0;\n  length = alignments.length;\n  lineCount--;\n  alignment = false;\n  align = [];\n\n  while (index < length) {\n    character = alignments.charAt(index);\n\n    if (character === C_PIPE) {\n      hasDash = null;\n\n      if (alignment === false) {\n        if (first === false) {\n          return;\n        }\n      } else {\n        align.push(alignment);\n        alignment = false;\n      }\n\n      first = false;\n    } else if (character === C_DASH) {\n      hasDash = true;\n      alignment = alignment || TABLE_ALIGN_NONE;\n    } else if (character === C_COLON) {\n      if (alignment === TABLE_ALIGN_LEFT) {\n        alignment = TABLE_ALIGN_CENTER;\n      } else if (hasDash && alignment === TABLE_ALIGN_NONE) {\n        alignment = TABLE_ALIGN_RIGHT;\n      } else {\n        alignment = TABLE_ALIGN_LEFT;\n      }\n    } else if (!whitespace(character)) {\n      return;\n    }\n\n    index++;\n  }\n\n  if (alignment !== false) {\n    align.push(alignment);\n  }\n\n  /* Exit when without enough columns. */\n  if (align.length < MIN_TABLE_COLUMNS) {\n    return;\n  }\n\n  /* istanbul ignore if - never used (yet) */\n  if (silent) {\n    return true;\n  }\n\n  /* Parse the rows. */\n  position = -1;\n  rows = [];\n\n  table = eat(subvalue).reset({\n    type: 'table',\n    align: align,\n    children: rows\n  });\n\n  while (++position < lineCount) {\n    line = lines[position];\n    row = {type: 'tableRow', children: []};\n\n    /* Eat a newline character when this is not the\n     * first row. */\n    if (position) {\n      eat(C_NEWLINE);\n    }\n\n    /* Eat the row. */\n    eat(line).reset(row, table);\n\n    length = line.length + 1;\n    index = 0;\n    queue = '';\n    cell = '';\n    preamble = true;\n    count = null;\n    opening = null;\n\n    while (index < length) {\n      character = line.charAt(index);\n\n      if (character === C_TAB || character === C_SPACE) {\n        if (cell) {\n          queue += character;\n        } else {\n          eat(character);\n        }\n\n        index++;\n        continue;\n      }\n\n      if (character === '' || character === C_PIPE) {\n        if (preamble) {\n          eat(character);\n        } else {\n          if (character && opening) {\n            queue += character;\n            index++;\n            continue;\n          }\n\n          if ((cell || character) && !preamble) {\n            subvalue = cell;\n\n            if (queue.length > 1) {\n              if (character) {\n                subvalue += queue.slice(0, queue.length - 1);\n                queue = queue.charAt(queue.length - 1);\n              } else {\n                subvalue += queue;\n                queue = '';\n              }\n            }\n\n            now = eat.now();\n\n            eat(subvalue)({\n              type: 'tableCell',\n              children: self.tokenizeInline(cell, now)\n            }, row);\n          }\n\n          eat(queue + character);\n\n          queue = '';\n          cell = '';\n        }\n      } else {\n        if (queue) {\n          cell += queue;\n          queue = '';\n        }\n\n        cell += character;\n\n        if (character === C_BACKSLASH && index !== length - 2) {\n          cell += line.charAt(index + 1);\n          index++;\n        }\n\n        if (character === C_TICK) {\n          count = 1;\n\n          while (line.charAt(index + 1) === character) {\n            cell += character;\n            index++;\n            count++;\n          }\n\n          if (!opening) {\n            opening = count;\n          } else if (count >= opening) {\n            opening = 0;\n          }\n        }\n      }\n\n      preamble = false;\n      index++;\n    }\n\n    /* Eat the alignment row. */\n    if (!position) {\n      eat(C_NEWLINE + alignments);\n    }\n  }\n\n  return table;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}